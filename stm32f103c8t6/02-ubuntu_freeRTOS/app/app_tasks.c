#include "stm32f10x.h"
#include "delay.h"
#include "misc.h"
#include "led.h"
#include "key.h"
#include "usart.h"
#include "pwm.h"
#include "adxl345.h"
#include "kalman.h"
#include "pid.h"
#include "car.h"
#include "app_tasks.h"
#include "cli_commands.h"
#include "log_module.h"
#include <string.h>

/* Dimensions the buffer into which input characters are placed. */
#define cmdMAX_INPUT_SIZE          64

/* DEL acts as a backspace. */
#define cmdASCII_DEL               (0x7F)

/* Const messages output by the command console. */
static const char *const pcWelcomeMessage = "FreeRTOS Command Server.\r\nType Help to view a list of registered commands.\r\n\r\n>";
static const char *const pcEndOfOutputMessage = "\r\n\r\n[Press ENTER to execute the previous command again]\r\n>";
static const char *const pcNewLine = "\r\n";

static pid_calc_t stand_pid;
pid_calc_t *ppid = &stand_pid;

void task_main(void *pvParameters)
{
	signed char cRxedChar;
	uint8_t ucInputIndex = 0;
	BaseType_t xReturned;
	char *pcOutputString;
    static char cInputString[ cmdMAX_INPUT_SIZE ], cLastInputString[ cmdMAX_INPUT_SIZE ];
	TickType_t currentTickCount, TickCount;
	TickType_t lastTickCount, lastTimestampCount;

	usart_printf("Main Task Create!\r\n");

	/* Obtain the address of the output buffer.  Note there is no mutual
     * exclusion on this buffer as it is assumed only one command console interface
     * will be used at any one time. */
    pcOutputString = FreeRTOS_CLIGetOutputBuffer();

	/* Send the welcome message. */
    usart_printf((signed char *)pcWelcomeMessage);

	taskENTER_CRITICAL();
	create_subtasks();
	taskEXIT_CRITICAL();

	CLIRegisterCommands();

	lastTickCount = xTaskGetTickCount();

	while(1) {
		currentTickCount = xTaskGetTickCount();

		TickCount = currentTickCount - lastTickCount;
		if (TickCount > pdMS_TO_TICKS(500)) {
			lastTickCount = currentTickCount;
			led_switch();
		}

		if (usart_getc(&cRxedChar)) {
			/* Ensure exclusive access to the UART Tx. */
			usart_puts_mutex_take();
			/* Echo the character back. */
            usart_putc(cRxedChar);
			/* Was it the end of the line? */
			if((cRxedChar == '\n') || (cRxedChar == '\r')) {
				/* Just to space the output from the input. */
                usart_puts((signed char *)pcNewLine);

                /* See if the command is empty, indicating that the last command
                 * is to be executed again. */
                if(ucInputIndex == 0) {
                    /* Copy the last command back into the input string. */
                    strncpy(cInputString, cLastInputString, cmdMAX_INPUT_SIZE);
                }

                /* Pass the received command to the command interpreter.  The
                 * command interpreter is called repeatedly until it returns
                 * pdFALSE	(indicating there is no more output) as it might
                 * generate more than one string. */
                do {
                    /* Get the next output string from the command interpreter. */
                    xReturned = FreeRTOS_CLIProcessCommand(cInputString, pcOutputString, configCOMMAND_INT_MAX_OUTPUT_SIZE);

                    /* Write the generated string to the UART. */
					usart_puts(pcOutputString);
                } while(xReturned != pdFALSE);

                /* All the strings generated by the input command have been
                 * sent.  Clear the input string ready to receive the next command.
                 * Remember the command that was just processed first in case it is
                 * to be processed again. */
                strncpy(cLastInputString, cInputString, cmdMAX_INPUT_SIZE);
                ucInputIndex = 0;
                memset(cInputString, 0x00, cmdMAX_INPUT_SIZE);

                usart_puts((signed char *)pcEndOfOutputMessage);
			} else {
				if(cRxedChar == '\r') {
                    /* Ignore the character. */
                } else if((cRxedChar == '\b') || (cRxedChar == cmdASCII_DEL) ) {
                    /* Backspace was pressed.  Erase the last character in the
                     * string - if any. */
                    if(ucInputIndex > 0) {
                        ucInputIndex--;
                        cInputString[ucInputIndex] = '\0';
                    }
                } else {
                    /* A character was entered.  Add it to the string entered so
                     * far.  When a \n is entered the complete	string will be
                     * passed to the command interpreter. */
                    if((cRxedChar >= ' ') && (cRxedChar <= '~') ) {
                        if(ucInputIndex < cmdMAX_INPUT_SIZE) {
                            cInputString[ucInputIndex] = cRxedChar;
                            ucInputIndex++;
                        }
                    }
                }
			}
			/* Must ensure to give the mutex back. */
			usart_puts_mutex_give();
        }

		vTaskDelay(5);
	}
}

void subtask1_sensors(void *pvParameters)
{
	usart_printf("Sensors Task Create\r\n");

	while(1) {

		vTaskDelay(100);
	}
}

void subtask2_motors(void *pvParameters)
{
	TickType_t currentTickCount, TickCount;
	TickType_t lastTickCount, lastTimestampCount;
	kalman kfp, *pkfp = &kfp;
	int16_t xAxis, yAxis, zAxis, kxAxis;
	int32_t pidOut = 0;
	uint8_t keyValue = KEY_INVALID;

	key_init();
	adxl345_init();
	kalman_init(pkfp);
	pid_init(ppid, 0, PWM4_PER_MAX/3, PWM4_PER_MAX/2, PWM4_PER_MAX);
	pid_set_param(ppid, 23.5f, 0.11f, 0.01f);

	lastTickCount = xTaskGetTickCount();
	lastTimestampCount = lastTickCount;

	usart_printf("Motors Task Create!\r\n");

	while(1) {
		currentTickCount = xTaskGetTickCount();
		adxl345_read_x_axis(&xAxis);
		kxAxis = (int16_t)kalman_filter(pkfp, xAxis);
		pidOut = pid_calc(ppid, kxAxis);
		car_stand_control(pidOut);

		TickCount = currentTickCount - lastTickCount;
		if (TickCount > pdMS_TO_TICKS(500)) {
			lastTickCount = currentTickCount;

			TASK_MOTOR_PRINT("[%d] r%d k%d (p%d.%d i%d.%d d%d.%d) O:%d P:%d I:%d D:%d\r\n",
				currentTickCount / configTICK_RATE_HZ, xAxis, kxAxis,
				((uint32_t)(ppid->Kp*100))/100, ((uint32_t)(ppid->Kp*100))%100,
				((uint32_t)(ppid->Ki*100))/100, ((uint32_t)(ppid->Ki*100))%100,
				((uint32_t)(ppid->Kd*100))/100, ((uint32_t)(ppid->Kd*100))%100,
				ppid->pidOut, ppid->pOut, ppid->iOut, ppid->dOut);
		}

		if (keyValue = key_scan()) {
			switch(keyValue) {
				case KEY0_DOWN:
					ppid->Kp -= 2.0;
					// ppid->Ki -= 0.01;
					break;
				case KEY1_UP:
					ppid->Kp += 2.0;
					// ppid->Ki += 0.01;
					break;
				default:
					break;
			}
		}

		vTaskDelay(10);
	}
}


